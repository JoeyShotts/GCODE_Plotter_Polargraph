import matplotlib.pyplot as plt
import numpy as np
import re

class plotPoints:
    """
    This class reads points from a file, and then plots them.
    It can optionally label the order of the points.
    It is instantiated with the filename, which cannot be changed.
    It simply plots the points in the the points.txt file, which are generated by 
    GeneratePoints.exe. It is not aware of when the plotter pen is down or up, but usually
    the plotter is up only for G00 (rapid position commands) where only the endpoints are in the points.txt file.
    This makes a convincing simulation.
    
    #Speed is the speed of the machine in mm/sec, all three inputs are used to calculate the 
    time it will take for the machine to plot the device.
    plotPoints.plotPoints(speed, numServoMoves, numCommands)

    """
    def __init__(self, __filename):
        self.__filename = __filename
        
        # List of points
        self.__x_coords = None
        self.__y_coords = None
        
        #Flag, text labels the points in order for debugging
        self.__add_text = False
        # Max number of points before it reduces points so plot will actually generate
        self.__maxPoints = 800000
        # Aproximate time for one command (sec)
        self.__singleCommandTime = 0.005
        # Aproximate time for on servo move (sec)
        self.__servoMoveTime = 0.3

        self.__numPoints = 0
        self.__x_coords = []
        self.__y_coords = []
    
    def plotPoints(self, speed, numServoMoves, numCommands):
        """
        Plots the points in a readable display. This function is called externally.
        """
        #Get points from file
        result, strResult = self.__getPointsFromFile()
        if not result:
            return result, strResult
        
        #Add text along point path if desired for debugging
        if self.__add_text:
            for i in range(len(self.__x_coords)):
                plt.annotate(f"{i}",             # The label text (index + 1)
                        (self.__x_coords[i], self.__x_coords[i]),     # The point being labeled
                        textcoords="offset points",
                        xytext=(0, 10),
                        ha='center')

        #Plot everything
        plt.plot(self.__x_coords, self.__y_coords, linestyle='', marker='o', markersize=3)
        
        programTime = self.__getPredictedTime(speed, numServoMoves, numCommands)

        plt.title(f"Polargraph Simulation.\nMax Estimated time {programTime:.2f} minutes.")
        plt.xlabel("X-axis")
        plt.ylabel("Y-axis")

        # Get the current axes object
        ax = plt.gca()

        # Autoscale the x-axis 
        ax.autoscale(enable=True, axis='x')

        # Get the x-axis limits
        x_min, x_max = ax.get_xlim()
        x_dis = x_max-x_min

        # Get the y-axis limits
        y_min, y_max = ax.get_ylim()
        y_dis = y_max-y_min
        
        # Set x and y distance to be same, choosing whichever axis is bigger
        if(x_dis>y_dis):
            ax.set_xlim(x_min, x_max)
            ax.set_ylim(y_min, (y_min+x_dis))
        else:
            ax.set_xlim(x_min, (x_min+y_dis))
            ax.set_ylim(y_min, y_max)

        #Set axes to always be an equal ratio
        ax.set_aspect('equal')

        plt.show()

        return True, "Points Plotted in Seperate Window"

    def __getPointsFromFile(self):
        """
        Gets points from a file, does some error checking and reduces points if needed.
        """
        points = self.__readPointsFromFileHelper()

        if isinstance(points, str):
            error = points
            print(error)
            return False, error

        self.__numPoints = len(points)

        try:
            self.__x_coords, self.__y_coords = zip(*points)
        except ValueError:
            error = "No Points to plot."
            print(error)
            return False, error
        
        #Reduce points if needed
        self.__reducePoints()

        return True, "Success."

    def __readPointsFromFileHelper(self):
        """
        Reads points of the form (X,Y) from a text file, assuming they might be on the same line.
        Returns them as a list of tuples. Faster version with regular expressions.
        """
        points = []
        try:
            with open(self.__filename, 'r') as file:
                content = file.read()
                # Regular expression to find patterns like (X,Y)
                # It looks for:
                # \( : a literal opening parenthesis
                # \s* : zero or more whitespace characters
                # (-?\d+\.?\d*) : a number (integer or float, possibly negative) for X
                # \s*,\s* : a comma surrounded by zero or more whitespace characters
                # (-?\d+\.?\d*) : a number (integer or float, possibly negative) for Y
                # \) : a literal closing parenthesis
                pattern = r'\(\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)\s*\)'
                
                for match in re.finditer(pattern, content):
                    try:
                        x = float(match.group(1))
                        y = float(match.group(2))
                        points.append((x, y))
                    except ValueError:
                        # This case should be rare if the regex is robust, 
                        # but it's good for safety if numbers are malformed.
                        print(f"Warning: Could not convert coordinates to numbers in: {match.group(0)}")
        except FileNotFoundError:
            print(f"Error: File not found at path: {self.__filename}")
        return points

    def __reducePoints(self):
        """
        Reduces number of points so they will be less than or close to max points.
        """
        #Calculate point reduction
        self.__numPoints = len(self.__x_coords)

        pointsPerStep = 1
        if (self.__numPoints > self.__maxPoints):
            pointsPerStep = round(self.__numPoints/self.__maxPoints)

        if pointsPerStep != 1:
            #Reduce number of points to managable amount
            __x_coords = []
            __y_coords = []
            for i in range(self.__numPoints):
                if i % pointsPerStep:
                    __x_coords.append(self.__x_coords[i])
                    __y_coords.append(self.__y_coords[i])

    def __getPredictedTime(self, speed, numServoMoves, numCmds):
        """
        Returns estimated time of a program in minutes.
        """
        self.__x_coords = np.pad(self.__x_coords, (1, 1), 'constant', constant_values=0)
        self.__y_coords = np.pad(self.__y_coords, (1, 1), 'constant', constant_values=0)

        distance = self.__calculate_line_distance_numpy()

        # speed(1 to 100)*10 = actualSpeed (steps/second)
        # speed(steps/sec)/10 = speed(mm/sec)
        # speed(1 to 100) = actualSpeed(mm/sec)
        moveTime = distance/speed

        commsTime = numCmds*self.__singleCommandTime
        servoTime = numServoMoves*self.__servoMoveTime
        
        totalTimeMinutes = (moveTime + commsTime + servoTime)/60
        
        return totalTimeMinutes


    def __calculate_line_distance_numpy(self):
        """
        Generated by google bard.
        Calculates the total distance of a line defined by arrays of x and y coordinates
        using NumPy for efficiency.

        Args:
            __x_coords (np.array or list): An array or list of x-coordinates.
            __y_coords (np.array or list): An array or list of y-coordinates.

        Returns:
            float: The total length of the line.
        """
        if len(self.__x_coords) != len(self.__y_coords):
            raise ValueError("__x_coords and __y_coords must have the same number of points.")
        if len(self.__x_coords) < 2:
            return 0.0 # A line needs at least two points to have a length

        # Ensure they are NumPy arrays for efficient computation
        __x_coords = np.asarray(self.__x_coords)
        __y_coords = np.asarray(self.__y_coords)

        # Calculate differences between consecutive points
        # __x_coords[1:] gives all elements from the second to the end
        # __x_coords[:-1] gives all elements from the beginning to the second to last
        dx = __x_coords[1:] - __x_coords[:-1]
        dy = __y_coords[1:] - __y_coords[:-1]

        # Calculate squared Euclidean distances for each segment
        # np.hypot(dx, dy) is a more numerically stable way to calculate sqrt(dx^2 + dy^2)
        # especially for very large or very small dx, dy values, preventing overflow/underflow.
        segment_distances = np.hypot(dx, dy)

        # Sum all segment distances to get the total length
        total_distance = np.sum(segment_distances)

        return total_distance